{"version":3,"file":"index.esm.min.js","sources":["../../src/serializer.ts","../../src/canonicalize.ts","../../src/canonicalize-ex.ts"],"sourcesContent":["export interface ISerializeOptions {\n  allowCircular?: boolean;\n  include?: string[];\n  exclude?: string | string[];\n  filterUndefined?: boolean;\n  undefinedInArrayToNull?: boolean;\n}\n\nexport function _serialize(obj: any, options?: ISerializeOptions) {\n  let buffer = '';\n  const vInclude = options && options.include;\n  let vExclude = options && options.exclude;\n  if (vExclude) {\n    if (typeof vExclude === 'string') vExclude = [vExclude];\n  }\n  if (vInclude) vInclude.sort();\n\n  const visited = new WeakMap<object, string>();\n  const allowCircular = options && options.allowCircular;\n  const filterUndefined = options && options.filterUndefined;\n  const undefinedInArrayToNull = options && options.undefinedInArrayToNull;\n\n  serialize(obj, '');\n\n  return buffer;\n\n  function serialize(object: any, path: string) {\n    if (\n      object === null ||\n      typeof object !== 'object' ||\n      object.toJSON != null\n    ) {\n      /////////////////////////////////////////////////\n      // Primitive data type - Use ES6/JSON          //\n      /////////////////////////////////////////////////\n      buffer += JSON.stringify(object);\n\n    } else if (Array.isArray(object)) {\n      /////////////////////////////////////////////////\n      // Array - Maintain element order              //\n      /////////////////////////////////////////////////\n      const visitedPath = visited.get(object);\n      if (visitedPath !== undefined) {\n        if (path.startsWith(visitedPath)) {\n          if (!allowCircular) {\n            throw new Error('Circular reference detected');\n          }\n          buffer += '\"[Circular]\"';\n\n          return;\n        }\n      }\n      visited.set(object, path);\n\n      buffer += '[';\n      let next = false;\n      object.forEach((element, index) => {\n        if (next) {\n          buffer += ',';\n        }\n        next = true;\n        if (undefinedInArrayToNull && element === undefined) {\n          element = null;\n        }\n        /////////////////////////////////////////\n        // Array element - Recursive expansion //\n        /////////////////////////////////////////\n        serialize(element, `${path}[${index}]`);\n      });\n      buffer += ']';\n    } else {\n      /////////////////////////////////////////////////\n      // Object - Sort properties before serializing //\n      /////////////////////////////////////////////////\n      const visitedPath = visited.get(object);\n      if (visitedPath !== undefined) {\n        if (path.startsWith(visitedPath)) {\n          if (!allowCircular) {\n            throw new Error('Circular reference detected');\n          }\n          buffer += '\"[Circular]\"';\n\n          return;\n        }\n      }\n      visited.set(object, path);\n\n      buffer += '{';\n      let next = false;\n\n      const addProp = (property: string) => {\n        if (vExclude && (vExclude as string[]).includes(property)) {\n          return;\n        }\n\n        if (next) {\n          buffer += ',';\n        }\n        next = true;\n        ///////////////////////////////////////////////\n        // Property names are strings - Use ES6/JSON //\n        ///////////////////////////////////////////////\n        buffer += JSON.stringify(property);\n        buffer += ':';\n        //////////////////////////////////////////\n        // Property value - Recursive expansion //\n        //////////////////////////////////////////\n        serialize(object[property], `${path}.${property}`);\n      };\n\n      if (path === '' && vInclude) {\n        vInclude.forEach((property) => {\n          if (object.hasOwnProperty(property)) {\n            addProp(property);\n          }\n        });\n      } else {\n        let vKeys = Object.keys(object);\n        if (filterUndefined) {\n          vKeys = vKeys.filter((k) => object[k] !== undefined);\n        }\n        vKeys.sort();\n        vKeys.forEach((property) => {\n          addProp(property);\n        });\n      }\n      buffer += '}';\n    }\n  }\n}\n","import { _serialize } from './serializer';\n\n/**\n * The main function for JSON canonicalization. It takes a JavaScript object and returns its canonical string representation.\n *\n * @param obj The JavaScript object to canonicalize.\n * @param allowCircular If `true`, the function will handle circular references in the object by replacing them with `null`. Defaults to `false`.\n * @returns The canonical string representation of the object.\n */\nexport function canonicalize(obj: any, allowCircular?: boolean) {\n  return _serialize(obj, {\n    allowCircular,\n    filterUndefined: true,\n    undefinedInArrayToNull: true,\n  });\n}\n","import { ISerializeOptions, _serialize } from './serializer';\n\n/**\n * The extended canonicalization function, offering more granular control over the serialization process.\n *\n * @param obj The JavaScript object to canonicalize.\n * @param options An object with the following properties:\n *  - `allowCircular` (boolean, optional): Same as in `canonicalize`.\n *  - `filterUndefined` (boolean, optional): If `true`, `undefined` values in objects will be filtered out. Defaults to `true`.\n *  - `undefinedInArrayToNull` (boolean, optional): If `true`, `undefined` values in arrays will be converted to `null`. Defaults to `true`.\n *  - `include` (string[], optional): An array of property names to include in the canonicalization.\n *  - `exclude` (string[], optional): An array of property names to exclude from the canonicalization.\n * @returns The canonical string representation of the object.\n */\nexport function canonicalizeEx(obj: any, options?: ISerializeOptions) {\n  return _serialize(obj, options);\n}\n"],"names":["_serialize","obj","options","buffer","vInclude","include","vExclude","exclude","sort","visited","WeakMap","allowCircular","filterUndefined","undefinedInArrayToNull","serialize","object","path","toJSON","JSON","stringify","Array","isArray","visitedPath","get","undefined","startsWith","Error","set","next","forEach","element","index","addProp","property","includes","hasOwnProperty","vKeys","Object","keys","filter","k","canonicalize","canonicalizeEx"],"mappings":"SAQgBA,EAAWC,EAAUC,GACnC,IAAIC,EAAS,GACb,MAAMC,EAAWF,GAAWA,EAAQG,QACpC,IAAIC,EAAWJ,GAAWA,EAAQK,QAC9BD,GACsB,iBAAbA,IAAuBA,EAAW,CAACA,IAE5CF,GAAUA,EAASI,OAEvB,MAAMC,EAAU,IAAIC,QACdC,EAAgBT,GAAWA,EAAQS,cACnCC,EAAkBV,GAAWA,EAAQU,gBACrCC,EAAyBX,GAAWA,EAAQW,uBAIlD,OAEA,SAASC,EAAUC,EAAaC,GAC9B,GACa,OAAXD,GACkB,iBAAXA,GACU,MAAjBA,EAAOE,OAKPd,GAAUe,KAAKC,UAAUJ,QAEpB,GAAIK,MAAMC,QAAQN,GAAS,CAIhC,MAAMO,EAAcb,EAAQc,IAAIR,GAChC,QAAoBS,IAAhBF,GACEN,EAAKS,WAAWH,GAAc,CAChC,IAAKX,EACH,MAAM,IAAIe,MAAM,+BAIlB,YAFAvB,GAAU,gBAKdM,EAAQkB,IAAIZ,EAAQC,GAEpBb,GAAU,IACV,IAAIyB,GAAO,EACXb,EAAOc,SAAQ,CAACC,EAASC,KACnBH,IACFzB,GAAU,KAEZyB,GAAO,EACHf,QAAsCW,IAAZM,IAC5BA,EAAU,MAKZhB,EAAUgB,EAAS,GAAGd,KAAQe,SAEhC5B,GAAU,QACL,CAIL,MAAMmB,EAAcb,EAAQc,IAAIR,GAChC,QAAoBS,IAAhBF,GACEN,EAAKS,WAAWH,GAAc,CAChC,IAAKX,EACH,MAAM,IAAIe,MAAM,+BAIlB,YAFAvB,GAAU,gBAKdM,EAAQkB,IAAIZ,EAAQC,GAEpBb,GAAU,IACV,IAAIyB,GAAO,EAEX,MAAMI,EAAWC,IACX3B,GAAaA,EAAsB4B,SAASD,KAI5CL,IACFzB,GAAU,KAEZyB,GAAO,EAIPzB,GAAUe,KAAKC,UAAUc,GACzB9B,GAAU,IAIVW,EAAUC,EAAOkB,GAAW,GAAGjB,KAAQiB,OAGzC,GAAa,KAATjB,GAAeZ,EACjBA,EAASyB,SAASI,IACZlB,EAAOoB,eAAeF,IACxBD,EAAQC,UAGP,CACL,IAAIG,EAAQC,OAAOC,KAAKvB,GACpBH,IACFwB,EAAQA,EAAMG,QAAQC,QAAoBhB,IAAdT,EAAOyB,MAErCJ,EAAM5B,OACN4B,EAAMP,SAASI,IACbD,EAAQC,MAGZ9B,GAAU,KAxGdW,CAAUb,EAAK,IAERE,WCfOsC,EAAaxC,EAAUU,GACrC,OAAOX,EAAWC,EAAK,CACrBU,cAAAA,EACAC,iBAAiB,EACjBC,wBAAwB,aCCZ6B,EAAezC,EAAUC,GACvC,OAAOF,EAAWC,EAAKC"}