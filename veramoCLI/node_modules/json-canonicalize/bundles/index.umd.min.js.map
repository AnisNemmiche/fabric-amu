{"version":3,"file":"index.umd.min.js","sources":["../../src/serializer.ts","../../src/canonicalize.ts","../../src/canonicalize-ex.ts"],"sourcesContent":["export interface ISerializeOptions {\n  allowCircular?: boolean;\n  include?: string[];\n  exclude?: string | string[];\n  filterUndefined?: boolean;\n  undefinedInArrayToNull?: boolean;\n}\n\nexport function _serialize(obj: any, options?: ISerializeOptions) {\n  let buffer = '';\n  const vInclude = options && options.include;\n  let vExclude = options && options.exclude;\n  if (vExclude) {\n    if (typeof vExclude === 'string') vExclude = [vExclude];\n  }\n  if (vInclude) vInclude.sort();\n\n  const visited = new WeakMap<object, string>();\n  const allowCircular = options && options.allowCircular;\n  const filterUndefined = options && options.filterUndefined;\n  const undefinedInArrayToNull = options && options.undefinedInArrayToNull;\n\n  serialize(obj, '');\n\n  return buffer;\n\n  function serialize(object: any, path: string) {\n    if (\n      object === null ||\n      typeof object !== 'object' ||\n      object.toJSON != null\n    ) {\n      /////////////////////////////////////////////////\n      // Primitive data type - Use ES6/JSON          //\n      /////////////////////////////////////////////////\n      buffer += JSON.stringify(object);\n\n    } else if (Array.isArray(object)) {\n      /////////////////////////////////////////////////\n      // Array - Maintain element order              //\n      /////////////////////////////////////////////////\n      const visitedPath = visited.get(object);\n      if (visitedPath !== undefined) {\n        if (path.startsWith(visitedPath)) {\n          if (!allowCircular) {\n            throw new Error('Circular reference detected');\n          }\n          buffer += '\"[Circular]\"';\n\n          return;\n        }\n      }\n      visited.set(object, path);\n\n      buffer += '[';\n      let next = false;\n      object.forEach((element, index) => {\n        if (next) {\n          buffer += ',';\n        }\n        next = true;\n        if (undefinedInArrayToNull && element === undefined) {\n          element = null;\n        }\n        /////////////////////////////////////////\n        // Array element - Recursive expansion //\n        /////////////////////////////////////////\n        serialize(element, `${path}[${index}]`);\n      });\n      buffer += ']';\n    } else {\n      /////////////////////////////////////////////////\n      // Object - Sort properties before serializing //\n      /////////////////////////////////////////////////\n      const visitedPath = visited.get(object);\n      if (visitedPath !== undefined) {\n        if (path.startsWith(visitedPath)) {\n          if (!allowCircular) {\n            throw new Error('Circular reference detected');\n          }\n          buffer += '\"[Circular]\"';\n\n          return;\n        }\n      }\n      visited.set(object, path);\n\n      buffer += '{';\n      let next = false;\n\n      const addProp = (property: string) => {\n        if (vExclude && (vExclude as string[]).includes(property)) {\n          return;\n        }\n\n        if (next) {\n          buffer += ',';\n        }\n        next = true;\n        ///////////////////////////////////////////////\n        // Property names are strings - Use ES6/JSON //\n        ///////////////////////////////////////////////\n        buffer += JSON.stringify(property);\n        buffer += ':';\n        //////////////////////////////////////////\n        // Property value - Recursive expansion //\n        //////////////////////////////////////////\n        serialize(object[property], `${path}.${property}`);\n      };\n\n      if (path === '' && vInclude) {\n        vInclude.forEach((property) => {\n          if (object.hasOwnProperty(property)) {\n            addProp(property);\n          }\n        });\n      } else {\n        let vKeys = Object.keys(object);\n        if (filterUndefined) {\n          vKeys = vKeys.filter((k) => object[k] !== undefined);\n        }\n        vKeys.sort();\n        vKeys.forEach((property) => {\n          addProp(property);\n        });\n      }\n      buffer += '}';\n    }\n  }\n}\n","import { _serialize } from './serializer';\n\n/**\n * The main function for JSON canonicalization. It takes a JavaScript object and returns its canonical string representation.\n *\n * @param obj The JavaScript object to canonicalize.\n * @param allowCircular If `true`, the function will handle circular references in the object by replacing them with `null`. Defaults to `false`.\n * @returns The canonical string representation of the object.\n */\nexport function canonicalize(obj: any, allowCircular?: boolean) {\n  return _serialize(obj, {\n    allowCircular,\n    filterUndefined: true,\n    undefinedInArrayToNull: true,\n  });\n}\n","import { ISerializeOptions, _serialize } from './serializer';\n\n/**\n * The extended canonicalization function, offering more granular control over the serialization process.\n *\n * @param obj The JavaScript object to canonicalize.\n * @param options An object with the following properties:\n *  - `allowCircular` (boolean, optional): Same as in `canonicalize`.\n *  - `filterUndefined` (boolean, optional): If `true`, `undefined` values in objects will be filtered out. Defaults to `true`.\n *  - `undefinedInArrayToNull` (boolean, optional): If `true`, `undefined` values in arrays will be converted to `null`. Defaults to `true`.\n *  - `include` (string[], optional): An array of property names to include in the canonicalization.\n *  - `exclude` (string[], optional): An array of property names to exclude from the canonicalization.\n * @returns The canonical string representation of the object.\n */\nexport function canonicalizeEx(obj: any, options?: ISerializeOptions) {\n  return _serialize(obj, options);\n}\n"],"names":["_serialize","obj","options","buffer","vInclude","include","vExclude","exclude","sort","visited","WeakMap","allowCircular","filterUndefined","undefinedInArrayToNull","serialize","object","path","toJSON","JSON","stringify","Array","isArray","undefined","visitedPath","get","startsWith","Error","set","next_1","forEach","element","index","next_2","addProp_1","property","includes","hasOwnProperty","vKeys","Object","keys","filter","k","canonicalize","canonicalizeEx"],"mappings":";;;;;;aAQgBA,WAAWC,EAAUC,GACnC,IAAIC,EAAS,GACPC,EAAWF,GAAWA,EAAQG,QAChCC,EAAWJ,GAAWA,EAAQK,QAC9BD,GACsB,iBAAbA,IAAuBA,EAAW,CAACA,IAE5CF,GAAUA,EAASI,OAEvB,IAAMC,EAAU,IAAIC,QACdC,EAAgBT,GAAWA,EAAQS,cACnCC,EAAkBV,GAAWA,EAAQU,gBACrCC,EAAyBX,GAAWA,EAAQW,uBAIlD,OAEA,SAASC,EAAUC,EAAaC,GAC9B,GACa,OAAXD,GACkB,iBAAXA,GACU,MAAjBA,EAAOE,OAKPd,GAAUe,KAAKC,UAAUJ,QAEpB,GAAIK,MAAMC,QAAQN,GAAS,CAKhC,QAAoBO,KADdC,EAAcd,EAAQe,IAAIT,KAE1BC,EAAKS,WAAWF,GAAc,CAChC,IAAKZ,EACH,MAAM,IAAIe,MAAM,+BAIlB,YAFAvB,GAAU,gBAKdM,EAAQkB,IAAIZ,EAAQC,GAEpBb,GAAU,IACV,IAAIyB,GAAO,EACXb,EAAOc,SAAQ,SAACC,EAASC,GACnBH,IACFzB,GAAU,KAEZyB,GAAO,EACHf,QAAsCS,IAAZQ,IAC5BA,EAAU,MAKZhB,EAAUgB,EAAYd,MAAQe,WAEhC5B,GAAU,UACL,CAIL,IAAMoB,EACN,QAAoBD,KADdC,EAAcd,EAAQe,IAAIT,KAE1BC,EAAKS,WAAWF,GAAc,CAChC,IAAKZ,EACH,MAAM,IAAIe,MAAM,+BAIlB,YAFAvB,GAAU,gBAKdM,EAAQkB,IAAIZ,EAAQC,GAEpBb,GAAU,IACV,IAAI6B,GAAO,EAELC,EAAU,SAACC,GACX5B,GAAaA,EAAsB6B,SAASD,KAI5CF,IACF7B,GAAU,KAEZ6B,GAAO,EAIP7B,GAAUe,KAAKC,UAAUe,GACzB/B,GAAU,IAIVW,EAAUC,EAAOmB,GAAclB,MAAQkB,MAGzC,GAAa,KAATlB,GAAeZ,EACjBA,EAASyB,SAAQ,SAACK,GACZnB,EAAOqB,eAAeF,IACxBD,EAAQC,YAGP,CACL,IAAIG,EAAQC,OAAOC,KAAKxB,GACpBH,IACFyB,EAAQA,EAAMG,QAAO,SAACC,GAAM,YAAcnB,IAAdP,EAAO0B,OAErCJ,EAAM7B,OACN6B,EAAMR,SAAQ,SAACK,GACbD,EAAQC,QAGZ/B,GAAU,MAxGdW,CAAUb,EAAK,IAERE;;aCfOuC,aAAazC,EAAUU,GACrC,OAAOX,WAAWC,EAAK,CACrBU,gBACAC,iBAAiB,EACjBC,wBAAwB;;aCCZ8B,eAAe1C,EAAUC,GACvC,OAAOF,WAAWC,EAAKC;;;;;;;;;;;"}